use std::path::PathBuf;

use nvim_oxi::{
    api::{self, Buffer, Window},
    mlua::{self, Lua},
};

#[derive(Debug)]
pub struct Location {
    pub dir_path: PathBuf,
    pub item: String,
}

#[derive(Debug)]
pub struct AppState {
    pub show_hidden: bool,
    pub history: Vec<Location>,
    pub selection: Vec<Location>,
    pub buf_content: Vec<String>,
    pub cwd: PathBuf,
    pub history_dir: PathBuf,
    pub win: Window,
    pub buf: Buffer,
}

impl AppState {
    pub fn new(lua: &Lua) -> nvim_oxi::Result<Self> {
        let mut buf = api::create_buf(false, true).unwrap();
        buf.set_option("bufhidden", "wipe")?;

        Ok(Self {
            show_hidden: false,
            history: vec![],
            selection: vec![],
            buf_content: vec![],
            cwd: Self::get_cwd(lua)?,
            history_dir: Self::get_history_dir(lua)?,
            win: api::get_current_win(),
            buf,
        })
    }

    pub fn get_cwd(lua: &Lua) -> nvim_oxi::Result<PathBuf> {
        let cwd_fn: mlua::Function = lua.load("vim.fn.getcwd").eval()?;

        Ok(cwd_fn.call::<(), String>(())?.into())
    }

    pub fn get_history_dir(lua: &Lua) -> nvim_oxi::Result<PathBuf> {
        let stdpath_fn: mlua::Function = lua.load("vim.fn.stdpath").eval()?;

        Ok(stdpath_fn.call::<&str, String>("state")?.into())
    }

    pub fn open_navigation(&mut self, lua: &Lua) -> nvim_oxi::Result<()> {
        api::set_current_buf(&self.buf)?;
        api::cmd("file Traveller");

        Ok(())
    }

}
